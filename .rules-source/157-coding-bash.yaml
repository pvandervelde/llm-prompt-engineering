- name: bash-arrays
  scope: repository
  editors:
    - name: copilot
      modes: [edit, agent]
    - name: cline
      modes: [act]
    - name: roo
      modes: [architect, code, debug, test]
  apply-to:
    - "**"
  text: |
    Use arrays for lists of data: `declare -a files=("file1" "file2")`. Use `"${array[@]}"`
    to expand all elements safely. Use `"${#array[@]}"` for array length. Use associative
    arrays with `declare -A` for key-value pairs. Always quote array expansions to
    handle spaces in elements. Use `readarray` or `mapfile` to read files into arrays.
    Iterate with `for item in "${array[@]}"`.

- name: bash-ci
  scope: user
  editors:
    - name: copilot
      modes: [edit, agent]
    - name: cline
      modes: [plan, act]
    - name: roo
      modes: [architect, code, test]
  apply-to:
    - "**"
  text: |
    Use `shellcheck` for static analysis and best practices validation. Test scripts
    with `bats` (Bash Automated Testing System). Validate scripts with `bash -n`
    for syntax checking. Test on multiple shells (bash, zsh, dash) if portability
    is required. Use Docker for testing across different Linux distributions.
    Include shell scripts in CI/CD pipelines with proper exit code handling.

- name: bash-command-substitution
  scope: repository
  editors:
    - name: copilot
      modes: [edit, agent]
    - name: cline
      modes: [act]
    - name: roo
      modes: [architect, code, debug, test]
  apply-to:
    - "**"
  text: |
    Use `$(command)` instead of backticks for command substitution. Handle command
    failures appropriately - command substitution doesn't propagate exit codes.
    Store command output in variables when used multiple times. Use `<(command)`
    for process substitution when reading command output as input. Quote command
    substitution results when they might contain spaces: `"$(command)"`.

- name: bash-conditionals
  scope: repository
  editors:
    - name: copilot
      modes: [edit, agent]
    - name: cline
      modes: [act]
    - name: roo
      modes: [architect, code, debug, test]
  apply-to:
    - "**"
  text: |
    Use `[[ ]]` for tests instead of `[ ]` - it's more reliable and feature-rich.
    Use `[[ -n "$var" ]]` to test if variable is not empty, `[[ -z "$var" ]]` for empty.
    Use appropriate file tests: `-f` for files, `-d` for directories, `-e` for existence.
    Use `==` for string equality, `=~` for regex matching. Always quote variables in
    tests unless using `[[ ]]` with simple variable names.

- name: bash-debugging
  scope: repository
  editors:
    - name: copilot
      modes: [edit, agent]
    - name: cline
      modes: [act]
    - name: roo
      modes: [code, debug, architect]
  apply-to:
    - "**"
  text: |
    Use `set -x` for tracing execution, `set -e` to exit on errors, `set -u` to
    exit on undefined variables, `set -o pipefail` to catch pipe failures. Use
    `set -euo pipefail` at script start for strict mode. Use `trap` for cleanup
    on script exit. Use `PS4='+ ${BASH_SOURCE}:${LINENO}: '` for better trace output.
    Use `DEBUG` trap for advanced debugging scenarios.

- name: bash-documentation
  scope: repository
  editors:
    - name: copilot
      modes: [ask, edit, agent]
    - name: cline
      modes: [plan, act]
    - name: roo
      modes: [architect, ask, code, debug, test]
  apply-to:
    - "**"
  text: |
    Include shebang line: `#!/bin/bash` (or `#!/usr/bin/env bash` for portability).
    Add script description, usage, and examples in header comments. Document functions
    with purpose, parameters, and return values. Use `#` for inline comments explaining
    complex logic. Include requirements, dependencies, and compatibility notes.
    Use consistent comment formatting and maintain up-to-date documentation.

- name: bash-error-handling
  scope: repository
  editors:
    - name: copilot
      modes: [edit, agent]
    - name: cline
      modes: [act]
    - name: roo
      modes: [code, debug]
  apply-to:
    - "**"
  text: |
    Use `set -e` to exit on command failures. Check exit codes explicitly for
    critical commands: `if ! command; then exit 1; fi`. Use `trap` for cleanup
    on exit, error, or signal. Use `|| exit 1` or `|| return 1` for explicit
    error handling. Provide meaningful error messages to stderr: `echo "Error: message" >&2`.
    Use consistent exit codes (0 success, 1-255 for different error types).

- name: bash-file-operations
  scope: repository
  editors:
    - name: copilot
      modes: [edit, agent]
    - name: cline
      modes: [act]
    - name: roo
      modes: [architect, code, debug, test]
  apply-to:
    - "**"
  text: |
    Always check if files exist before operating on them: `[[ -f "$file" ]]`.
    Use `mktemp` for temporary files and directories. Set proper file permissions
    with `chmod` when creating files. Use file locking with `flock` for concurrent
    access. Read files line by line with `while IFS= read -r line; do ... done < "$file"`.
    Use `find` instead of `ls` for file listing in scripts.

- name: bash-formatting
  scope: repository
  editors:
    - name: copilot
      modes: [edit, agent]
    - name: cline
      modes: [act]
    - name: roo
      modes: [code, debug, architect]
  apply-to:
    - "**"
  text: |
    Use 2-space or 4-space indentation consistently. Use `shfmt` for automatic
    formatting. Break long lines at logical points (after `&&`, `||`, `|`).
    Align backslashes in multi-line commands. Use blank lines to separate logical
    sections. Keep lines under 120 characters when possible. Use consistent brace
    style for functions and conditionals.

- name: bash-functions
  scope: repository
  editors:
    - name: copilot
      modes: [edit, agent]
    - name: cline
      modes: [act]
    - name: roo
      modes: [architect, code, debug, test]
  apply-to:
    - "**"
  text: |
    Use `function_name() { ... }` syntax for function definition. Use `local` for
    function variables to avoid global scope pollution. Access parameters with
    `"$1"`, `"$2"`, etc., and `"$@"` for all parameters. Return status codes with
    `return`, output data with `echo` or `printf`. Use descriptive function names.
    Keep functions small and focused on single responsibility. Document function
    parameters and behavior.

- name: bash-input-output
  scope: repository
  editors:
    - name: copilot
      modes: [edit, agent]
    - name: cline
      modes: [act]
    - name: roo
      modes: [architect, code, debug, test]
  apply-to:
    - "**"
  text: |
    Use `printf` instead of `echo` for formatted output and portability. Read
    user input with `read -r` to preserve backslashes. Use here documents for
    multi-line input: `cat << 'EOF'`. Redirect stderr to stdout with `2>&1` or
    to files with `2>error.log`. Use `exec` for file descriptor manipulation.
    Always quote variables when used in output contexts.

- name: bash-loops
  scope: repository
  editors:
    - name: copilot
      modes: [edit, agent]
    - name: cline
      modes: [act]
    - name: roo
      modes: [architect, code, debug, test]
  apply-to:
    - "**"
  text: |
    Use `for item in "${array[@]}"` for array iteration. Use `while IFS= read -r line`
    for reading files. Use C-style loops `for ((i=0; i<10; i++))` for numeric iteration.
    Use `until` loops when waiting for conditions to become true. Break out of loops
    with `break`, continue with `continue`. Avoid parsing `ls` output in loops -
    use arrays or `find` instead.

- name: bash-naming-conventions
  scope: repository
  editors:
    - name: copilot
      modes: [edit, agent]
    - name: cline
      modes: [act]
    - name: roo
      modes: [architect, code, debug, test]
  apply-to:
    - "**"
  text: |
    Use snake_case for variable and function names. Use UPPER_CASE for constants
    and environment variables. Use lowercase for script names with hyphens for
    word separation. Prefix global variables with script name to avoid conflicts.
    Use descriptive names that indicate purpose. Avoid single-letter variables
    except for standard loop counters. Use `readonly` for constants.

- name: bash-parameter-expansion
  scope: repository
  editors:
    - name: copilot
      modes: [edit, agent]
    - name: cline
      modes: [act]
    - name: roo
      modes: [architect, code, debug, test]
  apply-to:
    - "**"
  text: |
    Use parameter expansion for string manipulation: `${var#prefix}`, `${var%suffix}`,
    `${var/old/new}`. Use `${var:-default}` for default values, `${var:?error}`
    for required variables. Use `${var:+value}` for conditional expansion. Use
    `${#var}` for string length. Prefer parameter expansion over external commands
    like `sed` or `cut` for simple string operations when possible.

- name: bash-performance
  scope: repository
  editors:
    - name: copilot
      modes: [edit, agent]
    - name: cline
      modes: [act]
    - name: roo
      modes: [architect, code, debug, test]
  apply-to:
    - "**"
  text: |
    Avoid spawning subprocesses unnecessarily - use bash built-ins when possible.
    Use parameter expansion instead of `sed`/`awk` for simple string operations.
    Cache expensive command results in variables. Use `mapfile`/`readarray` instead
    of loops for reading files into arrays. Avoid repeated file system operations.
    Use `[[ ]]` instead of `test` or `[ ]`. Profile scripts with `time` command
    for performance analysis.

- name: bash-pipelines
  scope: repository
  editors:
    - name: copilot
      modes: [edit, agent]
    - name: cline
      modes: [act]
    - name: roo
      modes: [architect, code, debug, test]
  apply-to:
    - "**"
  text: |
    Use `set -o pipefail` to catch failures in pipeline commands. Be aware that
    only the last command's exit code is returned by default. Use intermediate
    variables or process substitution when you need to check exit codes of
    multiple pipeline commands. Format long pipelines with line breaks and proper
    indentation. Use `tee` when you need to both save and pass through data.

- name: bash-portability
  scope: repository
  editors:
    - name: copilot
      modes: [edit, agent]
    - name: cline
      modes: [act]
    - name: roo
      modes: [architect, code, debug, test]
  apply-to:
    - "**"
  text: |
    Use POSIX-compliant features when portability is required. Test scripts on
    different shells (bash, dash, zsh) and systems (Linux, macOS, BSD). Use
    `/usr/bin/env bash` shebang for better portability. Avoid bash-specific
    features like `[[`, arrays, and parameter expansion if targeting POSIX sh.
    Use `command -v` instead of `which` for checking command existence.
    Handle different versions of common utilities (GNU vs BSD).

- name: bash-release-management
  scope: user
  editors:
    - name: copilot
      modes: [edit, agent]
    - name: cline
      modes: [plan, act]
    - name: roo
      modes: [architect, code]
  apply-to:
    - "**"
  text: |
    Version scripts with semantic versioning in comments or variables. Use git
    tags for script releases. Create installation scripts or packages (deb, rpm)
    for distribution. Document installation requirements and dependencies. Use
    configuration files instead of hardcoded values. Provide upgrade and rollback
    procedures. Test installation and upgrade procedures on clean systems.

- name: bash-security
  scope: repository
  editors:
    - name: copilot
      modes: [edit, agent]
    - name: cline
      modes: [act]
    - name: roo
      modes: [architect, code, debug, test]
  apply-to:
    - "**"
  text: |
    Always quote variables to prevent word splitting and glob expansion: `"$var"`.
    Validate all input parameters and file paths. Use `mktemp` for temporary files
    with proper permissions. Avoid `eval` with untrusted input. Use full paths
    for commands or set `PATH` explicitly. Never store secrets in scripts - use
    environment variables or external secret management. Use `umask` to set secure
    default permissions. Sanitize input used in file operations.

- name: bash-testing
  scope: repository
  editors:
    - name: copilot
      modes: [edit, agent]
    - name: cline
      modes: [act]
    - name: roo
      modes: [code, test, debug]
  apply-to:
    - "**"
  text: |
    Use `bats` (Bash Automated Testing System) for testing bash scripts. Test
    both success and failure cases. Mock external dependencies when testing.
    Test with different input types and edge cases. Use `@test` annotations
    in bats for test descriptions. Test exit codes and output content. Use
    setup and teardown functions for test environment preparation. Include
    integration tests for complete script workflows.

- name: bash-variables
  scope: repository
  editors:
    - name: copilot
      modes: [edit, agent]
    - name: cline
      modes: [act]
    - name: roo
      modes: [architect, code, debug, test]
  apply-to:
    - "**"
  text: |
    Always quote variables unless you specifically need word splitting: `"$var"`.
    Use `readonly` for constants. Use `local` for function variables. Initialize
    variables before use. Use `declare` for complex variable types (arrays, integers).
    Use meaningful variable names that indicate their purpose. Check if variables
    are set with `[[ -n "${var:-}" ]]`. Use `${var}` form when concatenating with
    other text: `"${prefix}suffix"`.
