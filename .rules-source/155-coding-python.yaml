- name: python-async-patterns
  scope: repository
  editors:
    - name: copilot
      modes: [edit, agent]
    - name: cline
      modes: [act]
    - name: roo
      modes: [architect, code, debug, test]
  apply-to:
    - "**"
  text: |
    Use `async`/`await` for I/O-bound operations with asyncio. Use `aiohttp` for async
    HTTP requests, `asyncpg` for PostgreSQL, `motor` for MongoDB. Avoid mixing sync
    and async code - use `asyncio.run()` as entry point. Use `asyncio.gather()` for
    concurrent operations. Handle exceptions in async contexts with try/except around
    await calls. Use `asyncio.create_task()` for fire-and-forget operations.

- name: python-ci
  scope: user
  editors:
    - name: copilot
      modes: [edit, agent]
    - name: cline
      modes: [plan, act]
    - name: roo
      modes: [architect, code, test]
  apply-to:
    - "**"
  text: |
    Run `black`, `isort`, `flake8`/`ruff`, and `mypy` in CI pipeline. Use `pytest`
    with coverage reporting (`pytest --cov`). Use `safety` for security vulnerability
    scanning. Run `bandit` for security linting. Use `pre-commit` hooks for local
    validation. Test against multiple Python versions with `tox` or GitHub Actions matrix.

- name: python-collections
  scope: repository
  editors:
    - name: copilot
      modes: [edit, agent]
    - name: cline
      modes: [act]
    - name: roo
      modes: [architect, code, debug, test]
  apply-to:
    - "**"
  text: |
    Use appropriate collection types: `list` for ordered sequences, `set` for unique
    items, `dict` for key-value mapping. Use `collections.defaultdict`, `Counter`,
    `deque` when appropriate. Use `frozenset` for immutable sets. Prefer list/dict
    comprehensions over map/filter for simple operations. Use `itertools` for complex
    iteration patterns. Consider `typing.NamedTuple` or `dataclasses` for structured data.

- name: python-configuration
  scope: repository
  editors:
    - name: copilot
      modes: [edit, agent]
    - name: cline
      modes: [act]
    - name: roo
      modes: [architect, code, debug, test]
  apply-to:
    - "**"
  text: |
    Use `pydantic` for configuration validation and type conversion. Store config in
    environment variables, `.env` files, or YAML/TOML files. Use `python-dotenv` for
    .env file loading. Create configuration classes with sensible defaults. Validate
    configuration at startup. Use different config files for different environments
    (dev, staging, prod).

- name: python-data-classes
  scope: repository
  editors:
    - name: copilot
      modes: [edit, agent]
    - name: cline
      modes: [act]
    - name: roo
      modes: [architect, code, debug, test]
  apply-to:
    - "**"
  text: |
    Use `@dataclass` for simple data containers. Use `@dataclass(frozen=True)` for
    immutable objects. Use `pydantic.BaseModel` for data validation and serialization.
    Use `typing.NamedTuple` for simple immutable structures. Add type hints to all
    fields. Use `field()` for complex default values or metadata. Consider `slots=True`
    for memory efficiency.

- name: python-dependencies
  scope: repository
  editors:
    - name: copilot
      modes: [edit, agent]
    - name: cline
      modes: [plan, act]
    - name: roo
      modes: [architect, code]
  apply-to:
    - "**"
  text: |
    Use `poetry` or `pipenv` for dependency management and virtual environments. Pin
    exact versions in production (`poetry.lock`, `Pipfile.lock`). Use version ranges
    in development. Separate dev dependencies from production dependencies. Use
    `requirements.txt` only for simple projects. Update dependencies regularly and
    test for breaking changes. Use `pip-audit` for security scanning.

- name: python-documentation
  scope: repository
  editors:
    - name: copilot
      modes: [ask, edit, agent]
    - name: cline
      modes: [plan, act]
    - name: roo
      modes: [architect, ask, code, debug, test]
  apply-to:
    - "**"
  text: |
    Use docstrings for all public modules, classes, and functions. Follow Google,
    NumPy, or Sphinx docstring conventions consistently. Include Args, Returns,
    Raises sections. Use type hints instead of documenting types in docstrings.
    Generate documentation with Sphinx or mkdocs. Include examples in docstrings
    for complex functions. Use `"""` for multi-line docstrings.

- name: python-error-handling
  scope: repository
  editors:
    - name: copilot
      modes: [edit, agent]
    - name: cline
      modes: [act]
    - name: roo
      modes: [code, debug]
  apply-to:
    - "**"
  text: |
    Use specific exception types, not bare `except:`. Create custom exceptions
    inheriting from appropriate base classes. Use `raise ... from` for exception
    chaining. Use `else` clause in try/except for code that should run only if
    no exception occurred. Use `finally` for cleanup code. Consider using
    `contextlib.suppress()` for ignored exceptions. Log exceptions with full traceback.

- name: python-file-organization
  scope: repository
  editors:
    - name: copilot
      modes: [edit, agent]
    - name: cline
      modes: [plan, act]
    - name: roo
      modes: [architect, code, debug, test]
  apply-to:
    - "**"
  text: |
    Use `__init__.py` to make directories into packages. Import order: standard library,
    third-party packages, local modules (separated by blank lines). Use relative
    imports for same package, absolute imports otherwise. Keep modules under 500 lines.
    Use meaningful module and package names. Follow PEP 8 naming: `module_name.py`,
    `package_name/`.

- name: python-formatting
  scope: repository
  editors:
    - name: copilot
      modes: [edit, agent]
    - name: cline
      modes: [act]
    - name: roo
      modes: [code, debug, architect]
  apply-to:
    - "**"
  text: |
    Use `black` for code formatting with line length 88. Use `isort` for import
    sorting. Configure both tools consistently in `pyproject.toml`. Use `ruff` as
    a fast alternative to flake8 + isort + black. Follow PEP 8 for naming conventions.
    Use trailing commas in multi-line data structures. Limit lines to 88-100 characters.

- name: python-functions
  scope: repository
  editors:
    - name: copilot
      modes: [edit, agent]
    - name: cline
      modes: [act]
    - name: roo
      modes: [architect, code, debug, test]
  apply-to:
    - "**"
  text: |
    Use type hints for all function parameters and return values. Use `*args` and
    `**kwargs` judiciously. Prefer keyword-only arguments for complex functions
    (`def func(*, param: str)`). Use default values carefully - avoid mutable defaults.
    Keep functions small and focused on single responsibility. Use `functools.lru_cache`
    for expensive pure functions. Consider `functools.partial` for partial application.

- name: python-logging
  scope: repository
  editors:
    - name: copilot
      modes: [edit, agent]
    - name: cline
      modes: [act]
    - name: roo
      modes: [architect, code, debug, test]
  apply-to:
    - "**"
  text: |
    Use the `logging` module, not `print()` for debugging. Create logger per module:
    `logger = logging.getLogger(__name__)`. Use appropriate log levels: DEBUG, INFO,
    WARNING, ERROR, CRITICAL. Use f-strings or % formatting for log messages, not
    .format(). Use structured logging with `structlog` for production systems.
    Configure logging in main module, not libraries.

- name: python-naming-conventions
  scope: repository
  editors:
    - name: copilot
      modes: [edit, agent]
    - name: cline
      modes: [act]
    - name: roo
      modes: [architect, code, debug, test]
  apply-to:
    - "**"
  text: |
    Use snake_case for functions, variables, and modules. Use PascalCase for classes.
    Use SCREAMING_SNAKE_CASE for constants. Prefix private attributes with single
    underscore. Use double underscore prefix for name mangling sparingly. Use
    descriptive names - avoid abbreviations. Boolean variables should be positive
    and answerable with yes/no (is_active, has_permission).

- name: python-object-oriented
  scope: repository
  editors:
    - name: copilot
      modes: [edit, agent]
    - name: cline
      modes: [act]
    - name: roo
      modes: [architect, code, debug, test]
  apply-to:
    - "**"
  text: |
    Use `@property` for computed attributes and validation. Implement `__str__` for
    user-friendly representation, `__repr__` for debugging. Use `super()` for method
    resolution in inheritance. Prefer composition over inheritance. Use `@classmethod`
    for alternative constructors. Use `@staticmethod` for utility functions that
    don't need class/instance data. Implement context managers with `__enter__`/`__exit__`.

- name: python-performance
  scope: repository
  editors:
    - name: copilot
      modes: [edit, agent]
    - name: cline
      modes: [act]
    - name: roo
      modes: [architect, code, debug, test]
  apply-to:
    - "**"
  text: |
    Profile with `cProfile` and `line_profiler` before optimizing. Use list
    comprehensions over loops for simple transformations. Use `collections.deque`
    for frequent append/pop operations. Use `__slots__` for classes with many instances.
    Consider NumPy for numerical computations. Use `itertools` for memory-efficient
    iterators. Cache expensive operations with `@lru_cache`. Use generators for
    large datasets.

- name: python-release-management
  scope: user
  editors:
    - name: copilot
      modes: [edit, agent]
    - name: cline
      modes: [plan, act]
    - name: roo
      modes: [architect, code]
  apply-to:
    - "**"
  text: |
    Use semantic versioning for packages. Use `bump2version` or `poetry version`
    for version management. Create wheel packages with `poetry build` or `python -m build`.
    Upload to PyPI with `twine` or `poetry publish`. Use GitHub Releases for
    release notes. Tag releases with version numbers. Automate releases with
    GitHub Actions or similar CI/CD tools.

- name: python-security
  scope: repository
  editors:
    - name: copilot
      modes: [edit, agent]
    - name: cline
      modes: [act]
    - name: roo
      modes: [architect, code, debug, test]
  apply-to:
    - "**"
  text: |
    Never store secrets in code - use environment variables or secret management
    systems. Validate all input data. Use parameterized queries for database access.
    Use `secrets` module for cryptographically secure random data. Keep dependencies
    updated and scan for vulnerabilities with `safety` or `pip-audit`. Use HTTPS
    for all external API calls. Sanitize data before logging to prevent information leakage.

- name: python-testing
  scope: repository
  editors:
    - name: copilot
      modes: [edit, agent]
    - name: cline
      modes: [act]
    - name: roo
      modes: [code, test, debug]
  apply-to:
    - "**"
  text: |
    Use `pytest` as the testing framework. Follow AAA pattern (Arrange, Act, Assert).
    Use descriptive test function names that explain the scenario. Use fixtures for
    test setup and teardown. Use `pytest.parametrize` for parameterized tests.
    Mock external dependencies with `unittest.mock` or `pytest-mock`. Aim for high
    test coverage but focus on critical business logic. Use `pytest-cov` for coverage reporting.

- name: python-type-hints
  scope: repository
  editors:
    - name: copilot
      modes: [edit, agent]
    - name: cline
      modes: [act]
    - name: roo
      modes: [architect, code, debug, test]
  apply-to:
    - "**"
  text: |
    Use type hints for all function signatures and class attributes. Import types
    from `typing` module. Use `Optional[T]` or `T | None` for nullable values.
    Use `Union[T, U]` or `T | U` for multiple types. Use generic types like
    `List[T]`, `Dict[K, V]`. Use `mypy` for static type checking. Use `TYPE_CHECKING`
    for forward references. Consider using `TypedDict` for structured dictionaries.

- name: python-virtual-environments
  scope: repository
  editors:
    - name: copilot
      modes: [edit, agent]
    - name: cline
      modes: [plan, act]
    - name: roo
      modes: [architect, code]
  apply-to:
    - "**"
  text: |
    Always use virtual environments for project isolation. Use `poetry`, `pipenv`,
    or `venv` for virtual environment management. Never install packages globally
    with pip. Use `.python-version` file for pyenv version pinning. Document Python
    version requirements in README and CI configuration. Use `poetry shell` or
    `pipenv shell` to activate environments. Include virtual environment directories
    in `.gitignore`.
