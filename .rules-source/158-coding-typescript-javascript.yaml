- name: ts-async-patterns
  scope: repository
  editors:
    - name: copilot
      modes: [edit, agent]
    - name: cline
      modes: [act]
    - name: roo
      modes: [architect, code, debug, test]
  apply-to:
    - "**"
  text: |
    Use `async`/`await` instead of `.then()` chains for better readability. Handle
    errors with try/catch blocks around await calls. Use `Promise.all()` for concurrent
    operations, `Promise.allSettled()` when some failures are acceptable. Avoid
    `async` without `await` - return the Promise directly. Use `AbortController`
    for cancellable operations. Prefer `Promise<T>` over callback patterns.

- name: ts-build-tooling
  scope: repository
  editors:
    - name: copilot
      modes: [edit, agent]
    - name: cline
      modes: [plan, act]
    - name: roo
      modes: [architect, code]
  apply-to:
    - "**"
  text: |
    Use Vite for modern build tooling, webpack for complex configurations. Configure
    TypeScript with strict settings in `tsconfig.json`. Use ESM modules (`import`/`export`)
    over CommonJS when possible. Configure path mapping with `@/*` aliases. Use
    separate `tsconfig.json` files for different environments (app, tests, build).
    Enable source maps for debugging. Use tree-shaking friendly exports.

- name: ts-ci
  scope: user
  editors:
    - name: copilot
      modes: [edit, agent]
    - name: cline
      modes: [plan, act]
    - name: roo
      modes: [architect, code, test]
  apply-to:
    - "**"
  text: |
    Run `tsc --noEmit` for type checking, `eslint` for linting, `prettier` for
    formatting. Use `vitest` or `jest` for testing with coverage reporting. Run
    `audit` for security vulnerabilities. Use `depcheck` for unused dependencies.
    Test across multiple Node.js versions for libraries. Use `playwright` or
    `cypress` for E2E testing. Include bundle size analysis in CI.

- name: ts-components
  scope: repository
  editors:
    - name: copilot
      modes: [edit, agent]
    - name: cline
      modes: [act]
    - name: roo
      modes: [architect, code, debug, test]
  apply-to:
    - "**"
  text: |
    Use functional components with hooks over class components in React. Define
    component props with TypeScript interfaces. Use `React.FC<Props>` or explicit
    return types. Implement proper key props for lists. Use `memo()` for expensive
    components. Prefer composition over inheritance. Use custom hooks for reusable
    stateful logic. Keep components small and focused on single responsibility.

- name: ts-data-structures
  scope: repository
  editors:
    - name: copilot
      modes: [edit, agent]
    - name: cline
      modes: [act]
    - name: roo
      modes: [architect, code, debug, test]
  apply-to:
    - "**"
  text: |
    Use `Map` for key-value pairs when keys aren't strings, `Set` for unique values.
    Use `Array` methods like `map()`, `filter()`, `reduce()` instead of loops.
    Use `Object.freeze()` for immutable objects, `as const` for readonly tuples.
    Prefer structured data with interfaces over generic objects. Use `WeakMap`
    and `WeakSet` for memory-efficient caching. Use typed arrays for binary data.

- name: ts-documentation
  scope: repository
  editors:
    - name: copilot
      modes: [ask, edit, agent]
    - name: cline
      modes: [plan, act]
    - name: roo
      modes: [architect, ask, code, debug, test]
  apply-to:
    - "**"
  text: |
    Use JSDoc comments for public APIs with `@param`, `@returns`, `@throws`, `@example`.
    Let TypeScript types serve as documentation - avoid redundant type documentation.
    Use meaningful variable and function names that reduce need for comments.
    Generate documentation with TypeDoc for libraries. Include README with setup,
    usage examples, and API overview. Document breaking changes in CHANGELOG.md.

- name: ts-error-handling
  scope: repository
  editors:
    - name: copilot
      modes: [edit, agent]
    - name: cline
      modes: [act]
    - name: roo
      modes: [code, debug]
  apply-to:
    - "**"
  text: |
    Use custom Error classes for different error types. Handle async errors with
    try/catch around await calls. Use Result<T, E> pattern for expected failures.
    Validate input data at boundaries (API endpoints, user input). Use type guards
    for runtime type checking. Log errors with sufficient context. Use error
    boundaries in React for UI error handling. Avoid swallowing errors silently.

- name: ts-file-organization
  scope: repository
  editors:
    - name: copilot
      modes: [edit, agent]
    - name: cline
      modes: [plan, act]
    - name: roo
      modes: [architect, code, debug, test]
  apply-to:
    - "**"
  text: |
    Use kebab-case for file names, PascalCase for component files. Organize by
    feature, not by file type (`features/auth/` not `components/`, `services/`).
    Use `index.ts` files for clean imports. Keep related files close together.
    Use absolute imports with path mapping. Separate types into `.types.ts` files
    for complex domains. Use `src/` directory for source code.

- name: ts-formatting
  scope: repository
  editors:
    - name: copilot
      modes: [edit, agent]
    - name: cline
      modes: [act]
    - name: roo
      modes: [code, debug, architect]
  apply-to:
    - "**"
  text: |
    Use Prettier for automatic formatting with consistent configuration. Use 2-space
    indentation for most projects. Use trailing commas in multi-line structures.
    Use single quotes for strings unless interpolation is needed. Configure line
    length to 80-100 characters. Use semicolons consistently. Format with `prettier --write`
    and lint with `eslint --fix`. Use EditorConfig for consistent editor settings.

- name: ts-functions
  scope: repository
  editors:
    - name: copilot
      modes: [edit, agent]
    - name: cline
      modes: [act]
    - name: roo
      modes: [architect, code, debug, test]
  apply-to:
    - "**"
  text: |
    Use arrow functions for short functions and callbacks. Use function declarations
    for hoisted functions and complex logic. Type all parameters and return values.
    Use optional parameters (`param?: type`) and default parameters appropriately.
    Use rest parameters (`...args: type[]`) instead of `arguments`. Keep functions
    pure when possible. Use function overloads for complex parameter combinations.

- name: ts-imports-exports
  scope: repository
  editors:
    - name: copilot
      modes: [edit, agent]
    - name: cline
      modes: [act]
    - name: roo
      modes: [architect, code, debug, test]
  apply-to:
    - "**"
  text: |
    Use named exports over default exports for better tree-shaking and refactoring.
    Group imports: external libraries first, then internal modules. Use type-only
    imports: `import type { Type } from './types'`. Use dynamic imports for code
    splitting: `const module = await import('./module')`. Avoid `import *` except
    for namespaces. Use `export { type Type }` for re-exporting types.

- name: ts-naming-conventions
  scope: repository
  editors:
    - name: copilot
      modes: [edit, agent]
    - name: cline
      modes: [act]
    - name: roo
      modes: [architect, code, debug, test]
  apply-to:
    - "**"
  text: |
    Use camelCase for variables, functions, and methods. Use PascalCase for classes,
    interfaces, types, and components. Use SCREAMING_SNAKE_CASE for constants.
    Use kebab-case for file names and URLs. Prefix interfaces with `I` only if
    needed for disambiguation. Use descriptive names that indicate purpose.
    Boolean variables should be positive and answerable with yes/no.

- name: ts-package-management
  scope: repository
  editors:
    - name: copilot
      modes: [edit, agent]
    - name: cline
      modes: [plan, act]
    - name: roo
      modes: [architect, code]
  apply-to:
    - "**"
  text: |
    Use pnpm for fast, disk-efficient package management, or npm/yarn for team
    consistency. Pin exact versions in package-lock for reproducible builds.
    Use `dependencies` for runtime code, `devDependencies` for build tools.
    Keep dependencies up to date and audit regularly. Use `engines` field to
    specify Node.js version requirements. Consider package bundle size impact.

- name: ts-performance
  scope: repository
  editors:
    - name: copilot
      modes: [edit, agent]
    - name: cline
      modes: [act]
    - name: roo
      modes: [architect, code, debug, test]
  apply-to:
    - "**"
  text: |
    Use `useMemo()` and `useCallback()` to prevent unnecessary re-renders in React.
    Implement code splitting with dynamic imports. Use Web Workers for CPU-intensive
    tasks. Optimize bundle size with tree-shaking and dead code elimination.
    Use `Object.freeze()` for immutable data. Avoid premature optimization -
    profile first. Use `console.time()` for performance measurement. Consider
    `requestIdleCallback()` for non-critical tasks.

- name: ts-release-management
  scope: user
  editors:
    - name: copilot
      modes: [edit, agent]
    - name: cline
      modes: [plan, act]
    - name: roo
      modes: [architect, code]
  apply-to:
    - "**"
  text: |
    Use semantic versioning for npm packages. Use conventional commits for automated
    changelog generation. Use `np` or `semantic-release` for automated publishing.
    Create GitHub releases with release notes. Use `npm pack` to test package
    contents before publishing. Tag releases in git. Use preview/beta releases
    for testing changes. Automate deployment with CI/CD pipelines.

- name: ts-security
  scope: repository
  editors:
    - name: copilot
      modes: [edit, agent]
    - name: cline
      modes: [act]
    - name: roo
      modes: [architect, code, debug, test]
  apply-to:
    - "**"
  text: |
    Sanitize all user input and validate data shapes. Use HTTPS for all external
    requests. Store secrets in environment variables, never in code. Use Content
    Security Policy (CSP) for web applications. Validate and sanitize data before
    rendering in DOM. Use `npm audit` and `snyk` for dependency vulnerability
    scanning. Implement proper authentication and authorization. Use CORS appropriately.

- name: ts-state-management
  scope: repository
  editors:
    - name: copilot
      modes: [edit, agent]
    - name: cline
      modes: [act]
    - name: roo
      modes: [architect, code, debug, test]
  apply-to:
    - "**"
  text: |
    Use React's built-in state management (`useState`, `useReducer`, Context)
    for simple state. Use Zustand or Redux Toolkit for complex application state.
    Keep state as local as possible. Use immutable updates for state changes.
    Consider React Query/TanStack Query for server state. Use state machines
    (XState) for complex state logic. Avoid prop drilling with Context API.

- name: ts-testing
  scope: repository
  editors:
    - name: copilot
      modes: [edit, agent]
    - name: cline
      modes: [act]
    - name: roo
      modes: [code, test, debug]
  apply-to:
    - "**"
  text: |
    Use Vitest or Jest for unit testing with TypeScript support. Use React Testing
    Library for component testing. Write tests that test behavior, not implementation.
    Use descriptive test names that explain the scenario. Mock external dependencies
    appropriately. Use `@testing-library/jest-dom` for better assertions. Test
    error scenarios and edge cases. Aim for high test coverage on critical business logic.

- name: ts-type-safety
  scope: repository
  editors:
    - name: copilot
      modes: [edit, agent]
    - name: cline
      modes: [act]
    - name: roo
      modes: [architect, code, debug, test]
  apply-to:
    - "**"
  text: |
    Enable strict TypeScript settings: `strict`, `noImplicitAny`, `exactOptionalPropertyTypes`.
    Use type guards for runtime type checking. Prefer `unknown` over `any` for
    unsafe types. Use union types and discriminated unions for type safety.
    Use generic types for reusable components. Use `satisfies` operator for type
    checking without type widening. Avoid `as` assertions unless absolutely necessary.

- name: ts-utilities
  scope: repository
  editors:
    - name: copilot
      modes: [edit, agent]
    - name: cline
      modes: [act]
    - name: roo
      modes: [architect, code, debug, test]
  apply-to:
    - "**"
  text: |
    Use utility types like `Pick<T, K>`, `Omit<T, K>`, `Partial<T>`, `Required<T>`
    for type transformations. Use `Record<K, V>` for key-value types. Use template
    literal types for string manipulation. Create custom utility types for domain-specific
    transformations. Use conditional types sparingly and document complex ones.
    Use `keyof` and `typeof` for type inference from existing types.
